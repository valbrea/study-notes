/******************************************
 * ＃8：校门外的树
 * 
 * 描述
 * 某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。
 * 我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；
 * 数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。
 * 马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。
 * 已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。
 * 现在要把这些区域中的树（包括区域端点处的两棵树）移走。
 * 你的任务是计算将这些树都移走后，马路上还有多少棵树。
 * 
 * 输入
 * 输入的第一行有两个整数L（1 <= L <= 10000）和 M（1 <= M <= 100），
 * L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。
 * 接下来的M行每行包含两个不同的整数，用一个空格隔开，
 * 表示一个区域的起始点和终止点的坐标。
 * 
 * 输出
 * 输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。
 * ***********************************/

#include <iostream>
using namespace std;
int main()
{
    int l(0), m(0), count(0);
    cin >> l >> m;
    int aera[10000] = {0};      // 用aera来记录每个点上有没有树，有树==0，移走后就+1；
    int interval[100][2] = {0}; // 记录m个区间的起点和终点

    count = l + 1; // 总共有L+1棵树
    for (int i(0); i < m; i++)
    {
        cin >> interval[i][1] >> interval[i][2];
        // 对于区间中的每个点
        for (int j(interval[i][1]); j <= interval[i][2]; j++)
        {
            if (aera[j] == 0) // 如果有树
            {
                aera[j] += 1; // 移走
                count--;      // 计数-1
            }
        }
    }
    cout << count << endl;
    return 0;
}
/*****************************************************************************************************
     * 提示
     * 由于数据范围不大（L<=10000），我们可以使用一个10001长度的数组来记录每一个坐标上有没有树。
     * 但想象一下如果数据范围很大，比如下面这个情况，你怎么办呢？
     *
     * 解
     * 思考题部分如果仍然采用标记法，会导致程序所占内存过大，且时间复杂度在o(L*M)。因此，考虑从数轴上集合的关系入手。
     * 这道题的本质是求若干区间的并集，再在0～L这个大区间内求这个并集的补集，计算其中整数点的个数。
     * 如果我们得到的一系列区间是相互独立（也就是没有交集）的就好了，直接加加减减就能得到结果。但是事情并没有这么简单。
     * 我们知道：在数轴上，任意两个区间放在一起都只有两种情况：“有交集”和“无交集”。
     * 因此，我们可以通过程序的循环语句，遍历所有的“区间组合对”，先判断任意两个输入的区间有无交集。
     * 再将有交集的每一对区间求并，最终得到若干没有交集的独立区间即可达成目的。 
     * **/

/**********************************************************************
     * 解题代码
     * bool separation(int a_start, int a_end, int b_start, int b_end)
     * {
     *     return (a_start > b_end) || (b_start > a_end);
     * }
     * 
     * int main()
     * {
     *     int L = 0, M = 0;
     *     int a[100][2] = {0}; //存放每一个区间的起点和终点
     *     cin >> L >> M;
     *     int trees = L + 1;
     *     for (int i = 0; i < M; i++)
     *     {
     *         for (int j = 0; j < 2; j++)
     *         {
     *             cin >> a[i][j];
     *         }
     *     }
     * 
     *     //将所有区间两两组队，只要不是相离的区间，就是包含或者相交
     *     //计算这两个区间的并集，将结果的起始坐标和结束坐标保存到a[i]中
     *     //最后将a[j][0]和a[j][1]置-1
     *     for (int i = 0; i < M; i++)
     *     {
     *         for (int j = 0; j < M; j++)
     *         { //注意：这里j应该从0开始循环，遍历整个数组
     *             if (a[j][0] == -1 || i == j)
     *                 continue; //跳过a[j]继续循环
     *             else if (a[i][0] == -1)
     *             {
     *                 break; //跳过a[i]继续循环
     *             }
     *             else if (!separation(a[i][0], a[i][1], a[j][0], a[j][1]))
     *             {
     *                 a[i][0] = a[i][0] > a[j][0] ? a[j][0] : a[i][0];
     *                 a[i][1] = a[i][1] > a[j][1] ? a[i][1] : a[j][1];
     *                 a[j][0] = -1;
     *                 a[j][1] = -1;
     *             }
     *         }
     *     }
     * 
     *     //计算树木的数量
     *     for (int i = 0; i < M; i++)
     *     {
     *         if (a[i][0] != -1)
     *             trees = trees - (a[i][1] - a[i][0] + 1);
     *     }
***************************************************************************************/
