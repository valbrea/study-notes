/****************************************************
 * ＃7：中位数
 * 
 * 描述
 * 中位数定义：一组数据按从小到大的顺序依次排列，处在中间位置的一个数或最中间两个数据的平均值
 * （如果这组数的个数为奇数，则中位数为位于中间位置的那个数；
 * 如果这组数的个数为偶数，则中位数是位于中间位置的两个数的平均值）.
 * 给出一组无序整数，求出中位数，如果求最中间两个数的平均数，向下取整即可（不需要使用浮点数）
 * 
 * 输入
 * 该程序包含多组测试数据，每一组测试数据的第一行为N，代表该组测试数据包含的数据个数，1 <= N <= 15000.
 * 接着N行为N个数据的输入，N=0时结束输入
 * 
 * 输出
 * 输出中位数，每一组测试数据输出一行
 * ****************************************************/

#include <iostream>
using namespace std;
int main()
{
    int n(0), temp(0);
    cin >> n;
    int number[15000];
    for (int i(0); i < n; i++)
    {
        cin >> number[i];
    }
    // 排序方法
    for (int i(0); i < n - 1; i++)
    {
        for (int j(0); j < n - 1 - i; j++)
        {
            if (number[j] > number[j + 1])
            {
                temp = number[j];
                number[j] = number[j + 1];
                number[j + 1] = temp;
            }
        }
    }
    if (n % 2 == 1)
    {
        cout << number[(n - 1) / 2] << endl;   
    }
    else
    {
        cout << (number[n / 2 - 1] + number[n / 2]) / 2 << endl;
    }
/** 
 * 提示
 * 这是也一道经典的算法问题，在企业面试里出现概率很高，是“找到第K大的数”的变种。
 * 先排序再找中位数自然是很直接的做法，但排序本身很慢。
 * 我们只想找到第n/2大的数，对于其他数的顺序我们并不关心。
 * 那么怎么在不排序的前提下找到第n/2大的数呢？ 
 * 
 * 解2
 * 这个问题其实等价于找“K个最大的数”，就是每次对整个数组访问一遍，找到最大的数，然后挑出来。
 * 然后从挑出来的数中找到最小的（这个可以通过一个变量，存储当前挑出来的数中最小的来实现）。
 * 时间复杂度在O(kn)，当k比较大的时候，比如k>log(n)时，就不如排序了。
 * 
 * 解3
 * 二分，先扫一遍，找到最大，最小，然后二分，显然时间复杂度O(n∗log(n))，跟排序差不多。
 * 
 * 解4
 * 严格线性快速选择
 * */
    return 0;
}