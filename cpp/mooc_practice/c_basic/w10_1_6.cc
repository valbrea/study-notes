/*********************************************************************************************
 * ＃6：循环移动
 * 
 * 描述
 * 给定一组整数，要求利用数组把这组数保存起来，再利用实现对数组中的数循环移动。
 * 假定共有n个整数，则要使前面各数顺序向后移m个位置，并使最后m各数变为最前面的m各数。
 * 
 * 注意，不要用先输出后m个数，再输出前n-m个数的方法实现，也不要用两个数组的方式实现。
 * 要求只用一个数组的方式实现，一定要保证在输出结果时，输出的顺序和数组中数的顺序是一致的。
 * 
 * 输入
 * 输入有两行：第一行包含一个正整数n和一个正整数m，第二行包含n个正整数。每两个正整数中间用一个空格分开。
 * 
 * 输出
 * 输出有一行：经过循环移动后数组中整数的顺序依次输出，每两个整数之间用空格分隔。
 * 
 * 
 ********************************************************************************************/

#include <iostream>
using namespace std;
int main()
{
    int n(0), m(0);
    cin >> n >> m;
    int matrix[100];

    // 经典错误答案， 应该先录入数组，然后再移动，而不是直接移位录入
    /* for (int i(0); i < n; i++)
    {
        if (i < n - m)
        {
            cin >> matrix[i + m];
        }
        else
        {
            cin >> matrix[i + m - n];
        }
    } */

    // 录入元素
    for (int i(0); i < n; i++)
    {
        cin >> matrix[i];
    }
    // 先整体往后移
    for (int i(n - 1); i >= 0; i--)
    {
        matrix[i + m] = matrix[i];
    }
    // 再把后m个挪到前面去
    for (int i(n); i < n + m; i++)
    {
        matrix[i - n] = matrix[i];
    }
 /* * 提示
 * 这是一道经典的算法问题，在企业面试里出现概率很高。
 * 除了循环m次每次移动一个数以外（这样需要对数组操作m*n次），你还能想到更高效的算法吗（只用操作3*n次）？依然要求不使用额外数组，在原数组上移位之后顺序输出。 
 * 
 * 解
 * 我们定义a={1,2,3}的反为a'{3,2,1}。那么由ab变成ba,可以通过(a'b')'得到。
 * 因此我们可以写一个求反的子函数，用于求数组中特定部分元素的反。先对a求反，
 * 再对b求反，最后对整体求反，就可以得到结果。这里需要调用求反子函数3次即可。
 * */  


    // 输出
    for (int i(0); i < n; i++)
    {
        cout << matrix[i] << " ";
    }
    cout << endl;

    return 0;
}
